import React, { Suspense } from 'react';
import { logServerResponse, logCacheControlHeaders, logQueryTimings, getLoggerWithContext, } from './utilities/log';
import { getErrorMarkup } from './utilities/error';
import { defer } from './utilities/defer';
import { Html, applyHtmlHead } from './framework/Hydration/Html';
import { ServerComponentResponse } from './framework/Hydration/ServerComponentResponse.server';
import { ServerComponentRequest } from './framework/Hydration/ServerComponentRequest.server';
import { preloadRequestCacheData, ServerRequestProvider, } from './foundation/ServerRequestProvider';
import { getApiRouteFromURL, renderApiRoute, getApiRoutes, } from './utilities/apiRoutes';
import { ServerPropsProvider } from './foundation/ServerPropsProvider';
import { isBotUA } from './utilities/bot-ua';
import { setContext, setCache } from './framework/runtime';
import { setConfig } from './framework/config';
import { ssrRenderToPipeableStream, ssrRenderToReadableStream, rscRenderToReadableStream, createFromReadableStream, isStreamingSupported, bufferReadableStream, } from './streaming.server';
import { RSC_PATHNAME, EVENT_PATHNAME, EVENT_PATHNAME_REGEX } from './constants';
import { stripScriptsFromTemplate } from './utilities/template';
import { Analytics } from './foundation/Analytics/Analytics.server';
import { ServerAnalyticsRoute } from './foundation/Analytics/ServerAnalyticsRoute.server';
import { getSyncSessionApi } from './foundation/session/session';
import { parseJSON } from './utilities/parse';
import { htmlEncode } from './utilities';
const DOCTYPE = '<!DOCTYPE html>';
const CONTENT_TYPE = 'Content-Type';
const HTML_CONTENT_TYPE = 'text/html; charset=UTF-8';
export const renderHydrogen = (App) => {
    const handleRequest = async function (rawRequest, options) {
        const { indexTemplate, streamableResponse, dev, cache, context, nonce, buyerIpHeader, } = options;
        const request = new ServerComponentRequest(rawRequest);
        const url = new URL(request.url);
        const { default: inlineHydrogenConfig } = await import(
        // @ts-ignore
        // eslint-disable-next-line node/no-missing-import
        'virtual__hydrogen.config.ts');
        const { default: hydrogenRoutes } = await import(
        // @ts-ignore
        // eslint-disable-next-line node/no-missing-import
        'virtual__hydrogen-routes.server.jsx');
        const hydrogenConfig = {
            ...inlineHydrogenConfig,
            routes: hydrogenRoutes,
        };
        request.ctx.hydrogenConfig = hydrogenConfig;
        request.ctx.buyerIpHeader = buyerIpHeader;
        const log = getLoggerWithContext(request);
        const sessionApi = hydrogenConfig.session
            ? hydrogenConfig.session(log)
            : undefined;
        const componentResponse = new ServerComponentResponse();
        request.ctx.session = getSyncSessionApi(request, componentResponse, log, sessionApi);
        /**
         * Inject the cache & context into the module loader so we can pull it out for subrequests.
         */
        setCache(cache);
        setContext(context);
        setConfig({ dev });
        if (url.pathname === EVENT_PATHNAME ||
            EVENT_PATHNAME_REGEX.test(url.pathname)) {
            return ServerAnalyticsRoute(request, hydrogenConfig.serverAnalyticsConnectors);
        }
        const isReactHydrationRequest = url.pathname === RSC_PATHNAME;
        if (!isReactHydrationRequest) {
            const apiRoute = getApiRoute(url, hydrogenConfig.routes);
            // The API Route might have a default export, making it also a server component
            // If it does, only render the API route if the request method is GET
            if (apiRoute &&
                (!apiRoute.hasServerComponent || request.method !== 'GET')) {
                const apiResponse = await renderApiRoute(request, apiRoute, hydrogenConfig.shopify, sessionApi);
                return apiResponse instanceof Request
                    ? handleRequest(apiResponse, options)
                    : apiResponse;
            }
        }
        const isStreamable = (hydrogenConfig.enableStreaming
            ? hydrogenConfig.enableStreaming(request)
            : true) &&
            !isBotUA(url, request.headers.get('user-agent')) &&
            (!!streamableResponse || (await isStreamingSupported()));
        let template = typeof indexTemplate === 'function'
            ? await indexTemplate(url.toString())
            : indexTemplate;
        if (template && typeof template !== 'string') {
            template = template.default;
        }
        const params = {
            App,
            log,
            dev,
            nonce,
            request,
            template,
            isStreamable,
            componentResponse,
            response: streamableResponse,
        };
        if (isReactHydrationRequest) {
            return hydrate(url, params);
        }
        /**
         * Stream back real-user responses, but for bots/etc,
         * use `render` instead. This is because we need to inject <head>
         * things for SEO reasons.
         */
        if (isStreamable) {
            return stream(url, params);
        }
        return render(url, params);
    };
    if (__WORKER__)
        return handleRequest;
    return ((rawRequest, options) => handleFetchResponseInNode(handleRequest(rawRequest, options), options.streamableResponse));
};
function getApiRoute(url, routes) {
    const apiRoutes = getApiRoutes(routes);
    return getApiRouteFromURL(url, apiRoutes);
}
/**
 * The render function is responsible for turning the provided `App` into an HTML string,
 * and returning any initial state that needs to be hydrated into the client version of the app.
 * NOTE: This is currently only used for SEO bots or Worker runtime (where Stream is not yet supported).
 */
async function render(url, { App, request, template, componentResponse, nonce, log }) {
    const state = { pathname: url.pathname, search: url.search };
    const { AppSSR, rscReadable } = buildAppSSR({
        App,
        log,
        state,
        request,
        response: componentResponse,
    }, { template });
    function onErrorShell(error) {
        log.error(error);
        componentResponse.writeHead({ status: 500 });
        return template;
    }
    let [html, flight] = await Promise.all([
        renderToBufferedString(AppSSR, { log, nonce }).catch(onErrorShell),
        bufferReadableStream(rscReadable.getReader()).catch(() => null),
    ]);
    const { headers, status, statusText } = getResponseOptions(componentResponse);
    /**
     * TODO: Also add `Vary` headers for `accept-language` and any other keys
     * we want to shard our full-page cache for all Hydrogen storefronts.
     */
    headers.set('cache-control', componentResponse.cacheControlHeader);
    headers.set(CONTENT_TYPE, HTML_CONTENT_TYPE);
    html = applyHtmlHead(html, request.ctx.head, template);
    if (flight) {
        html = html.replace('</body>', () => flightContainer(flight) + '</body>');
    }
    postRequestTasks('ssr', status, request, componentResponse);
    return new Response(html, {
        status,
        statusText,
        headers,
    });
}
/**
 * Stream a response to the client. NOTE: This omits custom `<head>`
 * information, so this method should not be used by crawlers.
 */
async function stream(url, { App, request, response, componentResponse, template, nonce, dev, log, }) {
    var _a;
    const state = { pathname: url.pathname, search: url.search };
    log.trace('start stream');
    const { noScriptTemplate, bootstrapScripts, bootstrapModules } = stripScriptsFromTemplate(template);
    const { AppSSR, rscReadable, rscDidError } = buildAppSSR({
        App,
        log,
        state,
        request,
        response: componentResponse,
    }, { template: noScriptTemplate });
    const rscToScriptTagReadable = new ReadableStream({
        start(controller) {
            log.trace('rsc start chunks');
            const encoder = new TextEncoder();
            bufferReadableStream(rscReadable.getReader(), (chunk) => {
                const metaTag = flightContainer(chunk);
                controller.enqueue(encoder.encode(metaTag));
            }).then(() => {
                log.trace('rsc finish chunks');
                return controller.close();
            });
        },
    });
    let ssrDidError;
    if (__WORKER__) {
        const onCompleteAll = defer();
        const encoder = new TextEncoder();
        const transform = new TransformStream();
        const writable = transform.writable.getWriter();
        const responseOptions = {};
        let ssrReadable;
        try {
            ssrReadable = await ssrRenderToReadableStream(AppSSR, {
                nonce,
                bootstrapScripts,
                bootstrapModules,
                onError(error) {
                    ssrDidError = error;
                    if (dev && !writable.closed && !!responseOptions.status) {
                        writable.write(getErrorMarkup(error));
                    }
                    log.error(error);
                },
            });
        }
        catch (error) {
            log.error(error);
            return new Response(template + (dev ? getErrorMarkup(error) : ''), {
                status: 500,
                headers: { [CONTENT_TYPE]: HTML_CONTENT_TYPE },
            });
        }
        log.trace('worker ready to stream');
        ssrReadable.allReady.then(() => {
            log.trace('worker complete stream');
            onCompleteAll.resolve(true);
        });
        /* eslint-disable no-inner-declarations */
        function prepareForStreaming(flush) {
            Object.assign(responseOptions, getResponseOptions(componentResponse, rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError));
            /**
             * TODO: This assumes `response.cache()` has been called _before_ any
             * queries which might be caught behind Suspense. Clarify this or add
             * additional checks downstream?
             */
            responseOptions.headers.set('cache-control', componentResponse.cacheControlHeader);
            if (isRedirect(responseOptions)) {
                return false;
            }
            if (flush) {
                responseOptions.headers.set(CONTENT_TYPE, HTML_CONTENT_TYPE);
                writable.write(encoder.encode(DOCTYPE));
                if (rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError) {
                    // This error was delayed until the headers were properly sent.
                    writable.write(encoder.encode(getErrorMarkup((rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError))));
                }
                return true;
            }
        }
        /* eslint-enable no-inner-declarations */
        const shouldReturnApp = (_a = prepareForStreaming(componentResponse.canStream())) !== null && _a !== void 0 ? _a : (await onCompleteAll.promise.then(prepareForStreaming));
        if (shouldReturnApp) {
            let bufferedSsr = '';
            let isPendingSsrWrite = false;
            const writingSSR = bufferReadableStream(ssrReadable.getReader(), (chunk) => {
                bufferedSsr += chunk;
                if (!isPendingSsrWrite) {
                    isPendingSsrWrite = true;
                    setTimeout(() => {
                        isPendingSsrWrite = false;
                        // React can write fractional chunks synchronously.
                        // This timeout ensures we only write full HTML tags
                        // in order to allow RSC writing concurrently.
                        if (bufferedSsr) {
                            writable.write(encoder.encode(bufferedSsr));
                            bufferedSsr = '';
                        }
                    }, 0);
                }
            });
            const writingRSC = bufferReadableStream(rscToScriptTagReadable.getReader(), (scriptTag) => writable.write(encoder.encode(scriptTag)));
            Promise.all([writingSSR, writingRSC]).then(() => {
                // Last SSR write might be pending, delay closing the writable one tick
                setTimeout(() => writable.close(), 0);
                postRequestTasks('str', responseOptions.status, request, componentResponse);
            });
        }
        else {
            writable.close();
            postRequestTasks('str', responseOptions.status, request, componentResponse);
        }
        if (await isStreamingSupported()) {
            return new Response(transform.readable, responseOptions);
        }
        const bufferedBody = await bufferReadableStream(transform.readable.getReader());
        return new Response(bufferedBody, responseOptions);
    }
    else if (response) {
        const { pipe } = ssrRenderToPipeableStream(AppSSR, {
            nonce,
            bootstrapScripts,
            bootstrapModules,
            onShellReady() {
                log.trace('node ready to stream');
                /**
                 * TODO: This assumes `response.cache()` has been called _before_ any
                 * queries which might be caught behind Suspense. Clarify this or add
                 * additional checks downstream?
                 */
                response.setHeader('cache-control', componentResponse.cacheControlHeader);
                writeHeadToServerResponse(response, componentResponse, log, rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError);
                if (isRedirect(response)) {
                    // Return redirects early without further rendering/streaming
                    return response.end();
                }
                if (!componentResponse.canStream())
                    return;
                startWritingHtmlToServerResponse(response, dev ? rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError : undefined);
                setTimeout(() => {
                    log.trace('node pipe response');
                    pipe(response);
                }, 0);
                bufferReadableStream(rscToScriptTagReadable.getReader(), (chunk) => {
                    log.trace('rsc chunk');
                    return response.write(chunk);
                });
            },
            onAllReady() {
                log.trace('node complete stream');
                if (componentResponse.canStream() || response.writableEnded) {
                    postRequestTasks('str', response.statusCode, request, componentResponse);
                    return;
                }
                writeHeadToServerResponse(response, componentResponse, log, rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError);
                postRequestTasks('str', response.statusCode, request, componentResponse);
                if (isRedirect(response)) {
                    // Redirects found after any async code
                    return response.end();
                }
                startWritingHtmlToServerResponse(response, dev ? rscDidError !== null && rscDidError !== void 0 ? rscDidError : ssrDidError : undefined);
                bufferReadableStream(rscToScriptTagReadable.getReader()).then((scriptTags) => {
                    // Piping ends the response so script tags
                    // must be written before that.
                    response.write(scriptTags);
                    pipe(response);
                });
            },
            onShellError(error) {
                log.error(error);
                if (!response.writableEnded) {
                    writeHeadToServerResponse(response, componentResponse, log, error);
                    startWritingHtmlToServerResponse(response, dev ? error : undefined);
                    response.write(template);
                    response.end();
                }
            },
            onError(error) {
                ssrDidError = error;
                if (dev && response.headersSent) {
                    // Calling write would flush headers automatically.
                    // Delay this error until headers are properly sent.
                    response.write(getErrorMarkup(error));
                }
                log.error(error);
            },
        });
    }
}
/**
 * Stream a hydration response to the client.
 */
async function hydrate(url, { App, log, request, response, isStreamable, componentResponse, }) {
    const state = parseJSON(url.searchParams.get('state') || '{}');
    const { AppRSC } = buildAppRSC({
        App,
        log,
        state,
        request,
        response: componentResponse,
    });
    const rscReadable = rscRenderToReadableStream(AppRSC, {
        onError(e) {
            log.error(e);
        },
    });
    const bufferedBody = await bufferReadableStream(rscReadable.getReader());
    postRequestTasks('rsc', 200, request, componentResponse);
    return new Response(bufferedBody, {
        headers: {
            'cache-control': componentResponse.cacheControlHeader,
        },
    });
}
function buildAppRSC({ App, log, state, request, response }) {
    const hydrogenServerProps = { request, response, log };
    const serverProps = {
        ...state,
        ...hydrogenServerProps,
    };
    request.ctx.router.serverProps = serverProps;
    const AppRSC = (React.createElement(ServerRequestProvider, { request: request, isRSC: true },
        React.createElement(PreloadQueries, { request: request },
            React.createElement(App, { ...serverProps }),
            React.createElement(Suspense, { fallback: null },
                React.createElement(Analytics, null)))));
    return { AppRSC };
}
function buildAppSSR({ App, state, request, response, log }, htmlOptions) {
    const { AppRSC } = buildAppRSC({
        App,
        log,
        state,
        request,
        response,
    });
    let rscDidError;
    const [rscReadableForFizz, rscReadableForFlight] = rscRenderToReadableStream(AppRSC, {
        onError(e) {
            rscDidError = e;
            log.error(e);
        },
    }).tee();
    const rscResponse = createFromReadableStream(rscReadableForFizz);
    const RscConsumer = () => rscResponse.readRoot();
    const AppSSR = (React.createElement(Html, { ...htmlOptions },
        React.createElement(ServerRequestProvider, { request: request, isRSC: false },
            React.createElement(ServerPropsProvider, { initialServerProps: state, setServerPropsForRsc: () => { } },
                React.createElement(PreloadQueries, { request: request },
                    React.createElement(Suspense, { fallback: null },
                        React.createElement(RscConsumer, null)),
                    React.createElement(Suspense, { fallback: null },
                        React.createElement(Analytics, null)))))));
    return { AppSSR, rscReadable: rscReadableForFlight, rscDidError };
}
function PreloadQueries({ request, children, }) {
    const preloadQueries = request.getPreloadQueries();
    preloadRequestCacheData(request, preloadQueries);
    return React.createElement(React.Fragment, null, children);
}
async function renderToBufferedString(ReactApp, { log, nonce }) {
    if (__WORKER__) {
        const ssrReadable = await ssrRenderToReadableStream(ReactApp, {
            nonce,
            onError: (error) => log.error(error),
        });
        /**
         * We want to wait until `allReady` resolves before fetching the
         * stream body. Otherwise, React 18's streaming JS script/template tags
         * will be included in the output and cause issues when loading
         * the Client Components in the browser.
         */
        await ssrReadable.allReady;
        return bufferReadableStream(ssrReadable.getReader());
    }
    else {
        const writer = await createNodeWriter();
        return new Promise((resolve, reject) => {
            const { pipe } = ssrRenderToPipeableStream(ReactApp, {
                nonce,
                /**
                 * When hydrating, we have to wait until `onCompleteAll` to avoid having
                 * `template` and `script` tags inserted and rendered as part of the hydration response.
                 */
                onAllReady() {
                    let data = '';
                    writer.on('data', (chunk) => (data += chunk.toString()));
                    writer.once('error', reject);
                    writer.once('end', () => resolve(data));
                    // Tell React to start writing to the writer
                    pipe(writer);
                },
                onShellError: reject,
                onError: (error) => log.error(error),
            });
        });
    }
}
export default renderHydrogen;
function startWritingHtmlToServerResponse(response, error) {
    if (!response.headersSent) {
        response.setHeader(CONTENT_TYPE, HTML_CONTENT_TYPE);
        response.write(DOCTYPE);
    }
    if (error) {
        // This error was delayed until the headers were properly sent.
        response.write(getErrorMarkup(error));
    }
}
function getResponseOptions({ headers, status, customStatus }, error) {
    var _a, _b;
    const responseInit = {};
    responseInit.headers = headers;
    if (error) {
        responseInit.status = 500;
    }
    else {
        responseInit.status = (_b = (_a = customStatus === null || customStatus === void 0 ? void 0 : customStatus.code) !== null && _a !== void 0 ? _a : status) !== null && _b !== void 0 ? _b : 200;
        if (customStatus === null || customStatus === void 0 ? void 0 : customStatus.text) {
            responseInit.statusText = customStatus.text;
        }
    }
    return responseInit;
}
function writeHeadToServerResponse(response, serverComponentResponse, log, error) {
    if (response.headersSent)
        return;
    log.trace('writeHeadToServerResponse');
    const { headers, status, statusText } = getResponseOptions(serverComponentResponse, error);
    response.statusCode = status;
    if (statusText) {
        response.statusMessage = statusText;
    }
    setServerHeaders(headers, response);
}
function isRedirect(response) {
    var _a, _b;
    const status = (_b = (_a = response.status) !== null && _a !== void 0 ? _a : response.statusCode) !== null && _b !== void 0 ? _b : 0;
    return status >= 300 && status < 400;
}
async function createNodeWriter() {
    // Importing 'stream' directly breaks Vite resolve
    // when building for workers, even though this code
    // does not run in a worker. Looks like tree-shaking
    // kicks in after the import analysis/bundle.
    const streamImport = __WORKER__ ? '' : 'stream';
    const { PassThrough } = await import(streamImport);
    return new PassThrough();
}
function flightContainer(chunk) {
    return `<meta data-flight="${htmlEncode(chunk)}" />`;
}
function postRequestTasks(type, status, request, componentResponse) {
    logServerResponse(type, request, status);
    logCacheControlHeaders(type, request, componentResponse);
    logQueryTimings(type, request);
    request.savePreloadQueries();
}
/**
 * Ensure Node.js environments handle the fetch Response correctly.
 */
function handleFetchResponseInNode(fetchResponsePromise, nodeResponse) {
    if (nodeResponse) {
        fetchResponsePromise.then((response) => {
            if (!response)
                return;
            setServerHeaders(response.headers, nodeResponse);
            nodeResponse.statusCode = response.status;
            if (response.body) {
                nodeResponse.write(response.body);
            }
            nodeResponse.end();
        });
    }
    return fetchResponsePromise;
}
// From fetch Headers to Node Response
function setServerHeaders(headers, nodeResponse) {
    // Headers.raw is only implemented in node-fetch, which is used by Hydrogen in dev and prod.
    // It is the only way for now to access `set-cookie` header as an array.
    // https://github.com/Shopify/hydrogen/issues/1228
    Object.entries(headers.raw()).forEach(([key, value]) => nodeResponse.setHeader(key, value));
}
